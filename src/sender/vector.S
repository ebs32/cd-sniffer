    /***************************************************************************

      The ESP8266 implements 5 exceptions:

        - DebugExceptionVector
        - NMIExceptionVector
        - KernelExceptionVector
        - UserExceptionVector
        - DoubleExceptionVector

      During my tests, I found out that the NMIException is raised when the WiFi
      is started. The default exception handler calls to a C function that takes
      care of the interrupt generated by the WiFi module. I think the C function
      process the frames received from the WiFi module.

      On the other hand, the UserException is raised for all other interrupts in
      the ESP8266 and the LoadStoreError. The default exception handler calls to
      a C function, _xt_isr_handler, for handling the interrupts.

      The DebugException, the KernelException, the DoubleException and any other
      error not described previously in UserException will, generally, panic.

      Generally speaking, I found that it is safe to skip the default handler if
      the WiFi is not running. Otherwise, the system becomes unstable.

     **************************************************************************/

    #include "freertos/xtensa_rtos.h"

    #
    # Interrupt Vector
    #

    .section    .init

    .align      16
    .global     VectorBase                        # Export to C
VectorBase:

    /* DebugExceptionVector
     */
    .org        0x10
    j           _DebugExceptionVector

    /* NMIExceptionVector
     */
    .org        0x20
    j           _NMIExceptionVector

    /* KernelExceptionVector
     */
    .org        0x30
    j           _KernelExceptionVector

    /* UserExceptionVector
     */
    .org        0x50
    j           _UserExceptionHandler

    /* DoubleExceptionVector
     */
    .org        0x70
    j           _DoubleExceptionVector

    #
    # Handler Data
    #

    .section    .bss, "aw"

    .global     _UserExceptionHandlerData
    .align      4
_UserExceptionHandlerData:
    .word       0

    .global     _SkipHandler
    .align      4
_SkipHandler:
    .word       0

    .global     _Interrupt
    .align      4
_Interrupt:
    .word       0

    #
    # Handlers
    #

    .section    .text
    .type       _UserExceptionHandler, @function
    .align      4
_UserExceptionHandler:
    # Save A0
    wsr         a0,  EXCSAVE_1

    movi        a0,  _UserExceptionHandlerData
    s32i        a1,  a0,  0

    # Save Special Register INTERRUPT (#226) to _Interrupt
    rsr         a1,  interrupt
    movi        a0,  _Interrupt
    s32i        a1,  a0,  0

    movi        a0,  _UserExceptionHandlerData
    l32i        a1,  a0,  0

    # Jump to handler if the exception is other than the Level1Interrupt
    # exception or _SkipHandler is set to FALSE
    rsr         a0,  EXCCAUSE
    bnei        a0,  EXCCAUSE_LEVEL1INTERRUPT,  _JumpToHandler

    movi        a0,  _SkipHandler
    l32i        a0,  a0,  0
    bnez        a0,  _Skip

_JumpToHandler:
    rsr         a0,  EXCSAVE_1
    j           _UserExceptionVector

_Skip:
    #
    # Example of storing a value:
    #
    # movi        a0,  _UserExceptionHandlerData          # Save A1
    # s32i        a1,  a0,  0
    #
    # movi        a0,  _VariableName                      # Store PS
    # rsr         a1,  PS
    # s32i        a1,  a0,  0
    #
    # movi        a0,  _UserExceptionHandlerData          # Restore A1
    # l32i        a1,  a0,  0

    # Disable interrupts and switch to User Mode
    movi        a0,  PS_INTLEVEL(XCHAL_EXCM_LEVEL) | PS_UM
    wsr         a0,  PS

    # Restore A0
    rsr         a0,  EXCSAVE_1

    # Make sure PS register is updated
    rsync

    # Return and clear PS.EXCM bit
    rfe
